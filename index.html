<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Blog t√©cnico sobre Arquitectura de Software - Conceptos, Estilos y Patrones Arquitect√≥nicos Modernos">
    <meta name="author" content="Daniel Felipe Cifuentes Quiroga">
    <title>Blog T√©cnico - Arquitectura de Software</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <!-- ENCABEZADO PRINCIPAL -->
    <header class="main-header">
        <div class="header-content">
            <h1>üèóÔ∏è Arquitectura de Software</h1>
            <p class="subtitle">Blog T√©cnico sobre Conceptos, Estilos y Patrones Arquitect√≥nicos</p>
            <p class="author-info"><strong>Autor:</strong> Daniel Felipe Cifuentes Quiroga | <strong>COG:</strong> 84608</p>
        </div>
    </header>

    <!-- NAVEGACI√ìN -->
    <nav class="navbar">
        <div class="nav-container">
            <button class="nav-btn active" data-post="1">POST 1: ¬øQu√© es?</button>
            <button class="nav-btn" data-post="2">POST 2: Estilos</button>
            <button class="nav-btn" data-post="3">POST 3: Patrones</button>
        </div>
    </nav>

    <!-- CONTENEDOR PRINCIPAL -->
    <main class="container">
        <!-- POST 1: ¬øQu√© es la Arquitectura de Software? -->
        <article id="post-1" class="post-container active">
            <section class="post-header">
                <h2>POST 1: ¬øQu√© es la Arquitectura de Software?</h2>
                <p class="post-date">Publicado el: 3 de diciembre de 2025</p>
            </section>

            <section class="post-content">
                <h3>üìå Definici√≥n de Arquitectura de Software</h3>
                <p>
                    La <strong>Arquitectura de Software</strong> es el conjunto de decisiones de dise√±o de alto nivel que 
                    estructuran un sistema de software. Se trata de la organizaci√≥n fundamental del sistema, expresada a 
                    trav√©s de sus componentes, sus relaciones, los principios de dise√±o y las directrices que gobiernan su evoluci√≥n.
                </p>
                <p>
                    En otras palabras, la arquitectura de software define c√≥mo se organiza un proyecto a nivel macro, 
                    c√≥mo se comunican sus partes y c√≥mo se distribuyen las responsabilidades entre ellas.
                </p>

                <h3>üéØ Objetivo Principal de la Arquitectura en un Sistema</h3>
                <p>
                    El objetivo principal es crear una estructura clara, coherente y sostenible que permita:
                </p>
                <ul>
                    <li><strong>Mantener la complejidad bajo control:</strong> Dividiendo el sistema en componentes manejables</li>
                    <li><strong>Facilitar la comunicaci√≥n:</strong> Entre equipos de desarrollo</li>
                    <li><strong>Permitir cambios futuros:</strong> Sin comprometer la estabilidad del sistema</li>
                    <li><strong>Optimizar recursos:</strong> Tanto computacionales como humanos</li>
                    <li><strong>Garantizar calidad:</strong> A trav√©s de un dise√±o bien estructurado</li>
                </ul>

                <h3>üîß Componentes B√°sicos de una Arquitectura</h3>

                <div class="component-card">
                    <h4>1. M√≥dulos</h4>
                    <p>
                        Son unidades de software que encapsulan funcionalidad espec√≠fica. Cada m√≥dulo tiene 
                        responsabilidades bien definidas y puede ser desarrollado, probado y mantenido de forma independiente.
                    </p>
                    <p><strong>Ejemplo:</strong> En una aplicaci√≥n de e-commerce, podr√≠amos tener m√≥dulos para 
                    "Autenticaci√≥n", "Carrito de Compras", "Procesamiento de Pagos", etc.</p>
                </div>

                <div class="component-card">
                    <h4>2. Interfaces</h4>
                    <p>
                        Son los puntos de contacto entre m√≥dulos. Definen c√≥mo los componentes se comunican entre s√≠, 
                        sin necesidad de conocer detalles internos de implementaci√≥n.
                    </p>
                    <p><strong>Ejemplo:</strong> Una interfaz de API REST que expone endpoints para que otros m√≥dulos 
                    consuman datos de un servicio de usuario.</p>
                </div>

                <div class="component-card">
                    <h4>3. Conectores</h4>
                    <p>
                        Son los mecanismos de comunicaci√≥n entre componentes. Pueden ser llamadas a funciones, 
                        servicios web, colas de mensajes, bases de datos, etc.
                    </p>
                    <p><strong>Ejemplo:</strong> HTTP, gRPC, Message Queues (RabbitMQ), eventos de dominio.</p>
                </div>

                <h3>‚≠ê Importancia dentro del Desarrollo de Software</h3>

                <div class="importance-grid">
                    <div class="importance-item">
                        <h4>üìà Escalabilidad</h4>
                        <p>Una buena arquitectura permite que el sistema crezca sin perder rendimiento. 
                        Facilita agregar nuevas caracter√≠sticas y usuarios sin redise√±ar todo.</p>
                    </div>
                    <div class="importance-item">
                        <h4>üîß Mantenibilidad</h4>
                        <p>El c√≥digo bien estructurado es m√°s f√°cil de entender, modificar y corregir. 
                        Reduce el tiempo de desarrollo y la aparici√≥n de bugs.</p>
                    </div>
                    <div class="importance-item">
                        <h4>‚ö° Rendimiento</h4>
                        <p>Una arquitectura bien pensada optimiza el uso de recursos, reduciendo latencias 
                        y mejorando la experiencia del usuario.</p>
                    </div>
                    <div class="importance-item">
                        <h4>üõ°Ô∏è Confiabilidad</h4>
                        <p>Permite implementar mecanismos de tolerancia a fallos, recuperaci√≥n y redundancia 
                        de manera sistem√°tica.</p>
                    </div>
                </div>

                <h3>üëî Roles y Responsabilidades de un Arquitecto de Software</h3>
                <p>El <strong>Arquitecto de Software</strong> es el profesional responsable de:</p>
                <ul>
                    <li><strong>Dise√±ar la estructura global:</strong> Definir componentes, m√≥dulos y sus relaciones</li>
                    <li><strong>Tomar decisiones tecnol√≥gicas:</strong> Seleccionar frameworks, lenguajes, bases de datos</li>
                    <li><strong>Documentar:</strong> Crear diagramas y especificaciones claras</li>
                    <li><strong>Comunicar visi√≥n:</strong> Explicar el dise√±o a desarrolladores y stakeholders</li>
                    <li><strong>Resolver conflictos:</strong> Entre requisitos funcionales y no-funcionales</li>
                    <li><strong>Evaluar riesgos:</strong> Identificar problemas potenciales antes de implementar</li>
                    <li><strong>Revisar c√≥digo:</strong> Asegurar que la implementaci√≥n siga el dise√±o arquitect√≥nico</li>
                </ul>

                <h3>üìã Ejemplos de Arquitecturas en Proyectos Reales</h3>

                <div class="example-box">
                    <h4>Netflix</h4>
                    <p>
                        Utiliza una <strong>arquitectura de microservicios</strong> con miles de servicios independientes. 
                        Cada servicio es responsable de una funci√≥n espec√≠fica (usuarios, recomendaciones, streaming, etc.). 
                        Esto les permite escalar horizontalmente y actualizar servicios sin afectar el resto de la plataforma.
                    </p>
                </div>

                <div class="example-box">
                    <h4>Uber</h4>
                    <p>
                        Combina microservicios con una <strong>arquitectura event-driven</strong>. Los eventos (usuario solicit√≥ 
                        viaje, conductor acept√≥, etc.) se propagan a trav√©s de un sistema de mensajer√≠a, permitiendo que m√∫ltiples 
                        servicios reaccionen de forma desacoplada.
                    </p>
                </div>

                <div class="example-box">
                    <h4>Monolito Modular (Aplicaci√≥n Tradicional)</h4>
                    <p>
                        Muchas aplicaciones empresariales siguen una <strong>arquitectura en capas</strong> (presentaci√≥n, 
                        negocio, datos) dentro de un √∫nico proceso. Es m√°s simple de desplegar pero menos flexible que microservicios.
                    </p>
                </div>

                <h3>üéì Conclusi√≥n y Reflexi√≥n Final</h3>
                <p>
                    La Arquitectura de Software no es simplemente una tarea t√©cnica, sino una <strong>decisi√≥n estrat√©gica</strong> 
                    que impacta todo el proyecto. Una arquitectura bien dise√±ada:
                </p>
                <ul>
                    <li>Reduce costos de mantenimiento a largo plazo</li>
                    <li>Permite que equipos diferentes trabajen en paralelo</li>
                    <li>Facilita la integraci√≥n de nuevas tecnolog√≠as</li>
                    <li>Mejora la calidad y confiabilidad del software</li>
                </ul>
                <p>
                    Como desarrolladores, entender arquitectura nos permite no solo escribir mejor c√≥digo, 
                    sino tambi√©n pensar en c√≥mo nuestras decisiones afectan al sistema completo. 
                    Es la diferencia entre construir un "c√≥digo que funciona" y construir un "sistema que perdura".
                </p>
            </section>
        </article>

        <!-- POST 2: Estilos Arquitect√≥nicos m√°s Utilizados -->
        <article id="post-2" class="post-container">
            <section class="post-header">
                <h2>POST 2: Estilos Arquitect√≥nicos m√°s Utilizados</h2>
                <p class="post-date">Publicado el: 3 de diciembre de 2025</p>
            </section>

            <section class="post-content">
                <h3>üìå Definici√≥n de Estilo Arquitect√≥nico</h3>
                <p>
                    Un <strong>estilo arquitect√≥nico</strong> es un patr√≥n de organizaci√≥n y comunicaci√≥n 
                    entre componentes que define la estructura general de un sistema software. Es como un "patr√≥n de dise√±o" 
                    a nivel de sistema completo.
                </p>
                <p>
                    Cada estilo tiene sus propias caracter√≠sticas, ventajas y desventajas, y la elecci√≥n depende 
                    de los requisitos espec√≠ficos del proyecto.
                </p>

                <h3>1Ô∏è‚É£ Arquitectura Monol√≠tica</h3>

                <div class="style-card">
                    <h4>Caracter√≠sticas:</h4>
                    <ul>
                        <li>Todo el c√≥digo est√° en una sola aplicaci√≥n</li>
                        <li>Una √∫nica base de datos centralizada</li>
                        <li>Se despliega como una unidad √∫nica</li>
                        <li>Fuerte acoplamiento entre componentes</li>
                        <li>Compartici√≥n de frameworks y librer√≠as comunes</li>
                    </ul>
                </div>

                <div class="style-card">
                    <h4>‚úÖ Ventajas:</h4>
                    <ul>
                        <li><strong>Simple de desarrollar:</strong> En etapas iniciales</li>
                        <li><strong>F√°cil de depurar:</strong> Todo est√° en un lugar</li>
                        <li><strong>Mejor rendimiento:</strong> Sin latencias de red entre componentes</li>
                        <li><strong>Transacciones ACID:</strong> F√°ciles de implementar</li>
                        <li><strong>Menor complejidad operacional:</strong> Un √∫nico proceso a desplegar</li>
                    </ul>
                </div>

                <div class="style-card">
                    <h4>‚ùå Desventajas:</h4>
                    <ul>
                        <li><strong>Escalabilidad limitada:</strong> Solo escalado vertical</li>
                        <li><strong>Dificultad de mantenimiento:</strong> C√≥digo muy grande y complejo</li>
                        <li><strong>Rigidez tecnol√≥gica:</strong> Dif√≠cil cambiar frameworks o lenguajes</li>
                        <li><strong>Problema de inicio lento:</strong> Necesita cargar todo al iniciar</li>
                        <li><strong>Falla total:</strong> Un error cr√≠tico tumba toda la aplicaci√≥n</li>
                    </ul>
                </div>

                <h3>2Ô∏è‚É£ Arquitectura en Capas (N-Capas)</h3>

                <div class="style-card">
                    <h4>Caracter√≠sticas:</h4>
                    <ul>
                        <li>El sistema se organiza en capas horizontales</li>
                        <li>Cada capa tiene responsabilidades espec√≠ficas</li>
                        <li>T√≠picamente: Presentaci√≥n ‚Üí L√≥gica de Negocio ‚Üí Datos</li>
                        <li>Las capas superiores dependen de las inferiores</li>
                        <li>Comunicaci√≥n vertical entre capas</li>
                    </ul>

                    <p><strong>Capas t√≠picas:</strong></p>
                    <ul>
                        <li><strong>Capa de Presentaci√≥n:</strong> Interfaz de usuario (web, mobile, API)</li>
                        <li><strong>Capa de L√≥gica de Negocio:</strong> Reglas y procesos del negocio</li>
                        <li><strong>Capa de Persistencia:</strong> Acceso y gesti√≥n de datos</li>
                        <li><strong>Capa de Base de Datos:</strong> Almacenamiento f√≠sico de datos</li>
                    </ul>
                </div>

                <div class="style-card">
                    <h4>‚úÖ Ventajas:</h4>
                    <ul>
                        <li><strong>F√°cil de entender:</strong> Estructura clara y organizada</li>
                        <li><strong>Separaci√≥n de responsabilidades:</strong> Cada capa tiene un prop√≥sito</li>
                        <li><strong>Facilita pruebas:</strong> Se pueden testear capas de forma aislada</li>
                        <li><strong>Permite especializaci√≥n:</strong> Equipos por capa (frontend, backend, DB)</li>
                        <li><strong>Reutilizaci√≥n de c√≥digo:</strong> Capas inferiores se reutilizan</li>
                    </ul>
                </div>

                <div class="style-card">
                    <h4>‚ùå Desventajas:</h4>
                    <ul>
                        <li><strong>"Death by a thousand cuts":</strong> Cambios triviales requieren modificar todas las capas</li>
                        <li><strong>Rendimiento:</strong> M√∫ltiples saltos entre capas</li>
                        <li><strong>Escalabilidad limitada:</strong> Dif√≠cil escalar capas independientemente</li>
                        <li><strong>Depuraci√≥n compleja:</strong> Necesita seguir la pila de capas</li>
                    </ul>
                </div>

                <h3>3Ô∏è‚É£ Arquitectura Cliente-Servidor</h3>

                <div class="style-card">
                    <h4>Caracter√≠sticas:</h4>
                    <ul>
                        <li>Separaci√≥n clara entre cliente y servidor</li>
                        <li>El servidor centraliza la l√≥gica de negocio</li>
                        <li>El cliente solo maneja presentaci√≥n</li>
                        <li>Comunicaci√≥n a trav√©s de protocolos (HTTP, TCP, etc.)</li>
                        <li>M√∫ltiples clientes pueden conectarse al mismo servidor</li>
                    </ul>
                </div>

                <div class="style-card">
                    <h4>‚úÖ Ventajas:</h4>
                    <ul>
                        <li><strong>Centralizaci√≥n:</strong> L√≥gica de negocio en un solo lugar</li>
                        <li><strong>Seguridad:</strong> Datos sensibles protegidos en el servidor</li>
                        <li><strong>Escalabilidad:</strong> M√∫ltiples clientes sin modificar la l√≥gica</li>
                        <li><strong>F√°cil actualizaci√≥n:</strong> Cambios en servidor sin afectar clientes</li>
                        <li><strong>Compatibilidad:</strong> Clientes heterog√©neos (web, mobile, desktop)</li>
                    </ul>
                </div>

                <div class="style-card">
                    <h4>‚ùå Desventajas:</h4>
                    <ul>
                        <li><strong>Punto √∫nico de fallo:</strong> Si el servidor cae, todo se detiene</li>
                        <li><strong>Latencia de red:</strong> Comunicaci√≥n con overhead</li>
                        <li><strong>Complejidad de sincronizaci√≥n:</strong> M√∫ltiples clientes necesitan coordinaci√≥n</li>
                        <li><strong>Carga en servidor:</strong> Todo el procesamiento centralizado</li>
                    </ul>
                </div>

                <h3>4Ô∏è‚É£ Arquitectura MVC (Model-View-Controller)</h3>

                <div class="style-card">
                    <h4>Caracter√≠sticas:</h4>
                    <ul>
                        <li><strong>Model:</strong> L√≥gica de negocio y datos</li>
                        <li><strong>View:</strong> Presentaci√≥n e interfaz de usuario</li>
                        <li><strong>Controller:</strong> Orquesta la comunicaci√≥n entre Model y View</li>
                        <li>Separaci√≥n de conceptos</li>
                        <li>Model no tiene dependencia del View</li>
                    </ul>
                </div>

                <div class="style-card">
                    <h4>‚úÖ Ventajas:</h4>
                    <ul>
                        <li><strong>Separaci√≥n clara:</strong> F√°cil de entender y mantener</li>
                        <li><strong>Reutilizaci√≥n:</strong> Same Model, diferentes Views</li>
                        <li><strong>Pruebas:</strong> Se puede testear l√≥gica sin UI</li>
                        <li><strong>Equipos paralelos:</strong> Dise√±adores y programadores pueden trabajar juntos</li>
                    </ul>
                </div>

                <div class="style-card">
                    <h4>‚ùå Desventajas:</h4>
                    <ul>
                        <li><strong>Complejidad inicial:</strong> Puede ser excesivo para aplicaciones simples</li>
                        <li><strong>Controller graso:</strong> Tendencia a poner l√≥gica en el controller</li>
                        <li><strong>Acoplamiento View-Model:</strong> Cambios en datos requieren cambios en UI</li>
                    </ul>
                </div>

                <h3>5Ô∏è‚É£ Arquitectura de Microservicios</h3>

                <div class="style-card">
                    <h4>Caracter√≠sticas:</h4>
                    <ul>
                        <li>El sistema se divide en servicios peque√±os e independientes</li>
                        <li>Cada servicio tiene su propia base de datos</li>
                        <li>Se comunican a trav√©s de APIs REST, gRPC o message brokers</li>
                        <li>Pueden estar desarrollados en diferentes lenguajes</li>
                        <li>Se despliegan de forma independiente</li>
                    </ul>
                </div>

                <div class="style-card">
                    <h4>‚úÖ Ventajas:</h4>
                    <ul>
                        <li><strong>Escalabilidad horizontal:</strong> Escalar servicios independientemente</li>
                        <li><strong>Flexibilidad tecnol√≥gica:</strong> Cada servicio con su stack</li>
                        <li><strong>Resiliencia:</strong> Falla de un servicio no tumba todo</li>
                        <li><strong>Despliegues independientes:</strong> M√°s r√°pido ir a producci√≥n</li>
                        <li><strong>Alineaci√≥n con negocio:</strong> Servicios por √°reas de negocio</li>
                    </ul>
                </div>

                <div class="style-card">
                    <h4>‚ùå Desventajas:</h4>
                    <ul>
                        <li><strong>Complejidad operacional:</strong> M√∫ltiples servicios a gestionar</li>
                        <li><strong>Latencia de red:</strong> Comunicaci√≥n entre servicios</li>
                        <li><strong>Consistencia de datos:</strong> Transacciones distribuidas complejas</li>
                        <li><strong>Debugging dif√≠cil:</strong> Problemas distribuidos son m√°s complejos</li>
                        <li><strong>Requiere DevOps avanzado:</strong> Containers, orquestaci√≥n, monitoreo</li>
                    </ul>
                </div>

                <h3>üìä Tabla Comparativa de Estilos</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Caracter√≠stica</th>
                            <th>Monol√≠tico</th>
                            <th>N-Capas</th>
                            <th>Cliente-Servidor</th>
                            <th>MVC</th>
                            <th>Microservicios</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Complejidad</strong></td>
                            <td>Baja</td>
                            <td>Media</td>
                            <td>Media</td>
                            <td>Media</td>
                            <td>Alta</td>
                        </tr>
                        <tr>
                            <td><strong>Escalabilidad</strong></td>
                            <td>Baja</td>
                            <td>Media</td>
                            <td>Media</td>
                            <td>Media</td>
                            <td>Alta</td>
                        </tr>
                        <tr>
                            <td><strong>Rendimiento</strong></td>
                            <td>Alto</td>
                            <td>Medio</td>
                            <td>Medio</td>
                            <td>Medio</td>
                            <td>Bajo</td>
                        </tr>
                        <tr>
                            <td><strong>Mantenibilidad</strong></td>
                            <td>Baja</td>
                            <td>Alta</td>
                            <td>Alta</td>
                            <td>Alta</td>
                            <td>Alta</td>
                        </tr>
                        <tr>
                            <td><strong>Resiliencia</strong></td>
                            <td>Baja</td>
                            <td>Media</td>
                            <td>Media</td>
                            <td>Media</td>
                            <td>Alta</td>
                        </tr>
                        <tr>
                            <td><strong>Flexibilidad Tecnol√≥gica</strong></td>
                            <td>Baja</td>
                            <td>Media</td>
                            <td>Media</td>
                            <td>Media</td>
                            <td>Alta</td>
                        </tr>
                    </tbody>
                </table>

                <h3>üéØ Conclusi√≥n: ¬øCu√°ndo Usar Cada Estilo?</h3>

                <div class="recommendation-card">
                    <h4>üîπ Usa Monol√≠tico cuando:</h4>
                    <ul>
                        <li>Es un proyecto peque√±o o startup MVP</li>
                        <li>El equipo es muy peque√±o</li>
                        <li>Se requiere m√°ximo rendimiento</li>
                        <li>Las transacciones ACID son cr√≠ticas</li>
                    </ul>
                </div>

                <div class="recommendation-card">
                    <h4>üîπ Usa N-Capas cuando:</h4>
                    <ul>
                        <li>Aplicaciones empresariales medianas</li>
                        <li>Requieres separaci√≥n clara de responsabilidades</li>
                        <li>El equipo est√° organizado por capas</li>
                        <li>Necesitas mantenibilidad a largo plazo</li>
                    </ul>
                </div>

                <div class="recommendation-card">
                    <h4>üîπ Usa Cliente-Servidor cuando:</h4>
                    <ul>
                        <li>Necesitas m√∫ltiples clientes diferentes</li>
                        <li>La l√≥gica debe estar centralizada</li>
                        <li>Requieres seguridad en los datos</li>
                    </ul>
                </div>

                <div class="recommendation-card">
                    <h4>üîπ Usa MVC cuando:</h4>
                    <ul>
                        <li>Desarrollas aplicaciones web o mobile</li>
                        <li>Necesitas separaci√≥n View-Controller</li>
                        <li>Equipos trabajando en paralelo (designers + devs)</li>
                    </ul>
                </div>

                <div class="recommendation-card">
                    <h4>üîπ Usa Microservicios cuando:</h4>
                    <ul>
                        <li>Aplicaci√≥n a gran escala (Netflix, Uber, Amazon)</li>
                        <li>Equipos grandes y especializados</li>
                        <li>Requisitos de escalabilidad horizontal</li>
                        <li>Diferentes servicios con ciclos de vida independientes</li>
                        <li>Tienes infraestructura DevOps madura</li>
                    </ul>
                </div>
            </section>
        </article>

        <!-- POST 3: Patrones Arquitect√≥nicos Modernos -->
        <article id="post-3" class="post-container">
            <section class="post-header">
                <h2>POST 3: Patrones Arquitect√≥nicos Modernos</h2>
                <p class="post-date">Publicado el: 3 de diciembre de 2025</p>
            </section>

            <section class="post-content">
                <h3>üìå Definici√≥n de Patr√≥n Arquitect√≥nico</h3>
                <p>
                    Un <strong>patr√≥n arquitect√≥nico</strong> es una soluci√≥n general y reutilizable a un problema 
                    recurrente en el dise√±o de software. A diferencia de los estilos que definen la estructura global, 
                    los patrones proporcionan soluciones espec√≠ficas a problemas arquitect√≥nicos comunes.
                </p>
                <p>
                    Los patrones modernos buscan mejorar caracter√≠sticas como: escalabilidad, mantenibilidad, 
                    testabilidad, independencia de frameworks y flexibilidad t√©cnica.
                </p>

                <h3>1Ô∏è‚É£ Patr√≥n Clean Architecture</h3>

                <div class="pattern-card">
                    <h4>üìö Descripci√≥n General:</h4>
                    <p>
                        Propuesto por Robert C. Martin ("Uncle Bob"), Clean Architecture es un enfoque que organiza 
                        el c√≥digo en capas conc√©ntricas, donde cada capa tiene un nivel de abstracci√≥n diferente. 
                        El objetivo principal es que el negocio NO dependa de detalles t√©cnicos.
                    </p>
                </div>

                <div class="pattern-card">
                    <h4>üèóÔ∏è Las Cuatro Capas de Clean Architecture:</h4>
                    
                    <div class="layer-description">
                        <h5>1. Capa de Empresas (Enterprise Business Rules)</h5>
                        <p>
                            La capa m√°s interna. Contiene las reglas de negocio m√°s cr√≠ticas, 
                            completamente independientes de cualquier framework o tecnolog√≠a.
                        </p>
                        <p><strong>Ejemplo:</strong> Entidades del dominio, reglas de validaci√≥n de negocio.</p>
                    </div>

                    <div class="layer-description">
                        <h5>2. Capa de Aplicaci√≥n (Application Business Rules)</h5>
                        <p>
                            Contiene la l√≥gica de casos de uso espec√≠ficos. Orquesta las entidades 
                            y define c√≥mo se relacionan entre s√≠.
                        </p>
                        <p><strong>Ejemplo:</strong> Casos de uso, servicios de aplicaci√≥n.</p>
                    </div>

                    <div class="layer-description">
                        <h5>3. Capa de Adaptadores de Interfaz (Interface Adapters)</h5>
                        <p>
                            Traduce la comunicaci√≥n entre la capa de aplicaci√≥n y los marcos externos. 
                            Aqu√≠ van los controladores, gateways, presenters.
                        </p>
                        <p><strong>Ejemplo:</strong> Controladores REST, adaptadores a bases de datos, 
                        gateways de pagos.</p>
                    </div>

                    <div class="layer-description">
                        <h5>4. Capa de Frameworks y Drivers (Frameworks & Drivers)</h5>
                        <p>
                            La capa m√°s externa. Contiene detalles sobre frameworks, librer√≠as, 
                            bases de datos y cualquier herramienta externa.
                        </p>
                        <p><strong>Ejemplo:</strong> Spring Boot, Django, Express, PostgreSQL, MongoDB.</p>
                    </div>
                </div>

                <div class="pattern-card">
                    <h4>‚≠ê Principios de Clean Architecture:</h4>
                    <ul>
                        <li><strong>Independencia de Frameworks:</strong> El c√≥digo de negocio no depende de Spring, Django, etc.</li>
                        <li><strong>Testeable:</strong> La l√≥gica de negocio se puede testear sin UI, DB o servidor web</li>
                        <li><strong>Independencia de UI:</strong> Cambiar la interfaz no requiere cambiar la l√≥gica</li>
                        <li><strong>Independencia de Base de Datos:</strong> Cambiar de PostgreSQL a MongoDB es f√°cil</li>
                        <li><strong>Independencia de Agencias Externas:</strong> APIs de terceros no contaminan el core</li>
                    </ul>
                </div>

                <div class="pattern-card">
                    <h4>‚úÖ Ventajas de Clean Architecture:</h4>
                    <ul>
                        <li><strong>C√≥digo desacoplado:</strong> F√°cil cambiar tecnolog√≠as</li>
                        <li><strong>Altamente testeable:</strong> L√≥gica sin dependencias externas</li>
                        <li><strong>Enfoque en negocio:</strong> El dominio es el centro</li>
                        <li><strong>Longevidad:</strong> Proyectos que escalan en tiempo</li>
                        <li><strong>Mantenimiento f√°cil:</strong> C√≥digo claro y organizado</li>
                    </ul>
                </div>

                <div class="pattern-card">
                    <h4>‚ùå Desventajas de Clean Architecture:</h4>
                    <ul>
                        <li><strong>Curva de aprendizaje:</strong> Concepto complicado al principio</li>
                        <li><strong>Over-engineering para proyectos peque√±os:</strong> Puede ser excesivo para MVPs</li>
                        <li><strong>M√°s c√≥digo boilerplate:</strong> M√°s archivos y clases</li>
                        <li><strong>Equipo debe estar alineado:</strong> Requiere disciplina</li>
                    </ul>
                </div>

                <div class="pattern-card">
                    <h4>üí° Ejemplo Pr√°ctico:</h4>
                    <pre class="code-example">
// CAPA DE EMPRESAS (Entidades)
class Usuario {
    constructor(id, nombre, email) {
        this.id = id;
        this.nombre = nombre;
        this.email = email;
    }
    
    esValido() {
        return this.email.includes('@');
    }
}

// CAPA DE APLICACI√ìN (Caso de Uso)
class CrearUsuarioUseCase {
    constructor(usuarioRepository) {
        this.usuarioRepository = usuarioRepository;
    }
    
    ejecutar(nombre, email) {
        const usuario = new Usuario(null, nombre, email);
        
        if (!usuario.esValido()) {
            throw new Error('Email inv√°lido');
        }
        
        return this.usuarioRepository.guardar(usuario);
    }
}

// CAPA DE ADAPTADORES (Controlador REST)
class UsuarioController {
    constructor(crearUsuarioUseCase) {
        this.crearUsuarioUseCase = crearUsuarioUseCase;
    }
    
    post(req, res) {
        try {
            const usuario = this.crearUsuarioUseCase.ejecutar(
                req.body.nombre,
                req.body.email
            );
            res.json(usuario);
        } catch (error) {
            res.status(400).json({ error: error.message });
        }
    }
}

// CAPA DE FRAMEWORKS (Implementaci√≥n de Repositorio)
class UsuarioRepositoryPostgres {
    async guardar(usuario) {
        const query = 'INSERT INTO usuarios...';
        // Interactuar con PostgreSQL
    }
}
                    </pre>
                </div>

                <h3>2Ô∏è‚É£ Arquitectura Hexagonal (Puertos y Adaptadores)</h3>

                <div class="pattern-card">
                    <h4>üìö Descripci√≥n General:</h4>
                    <p>
                        Creada por Alistair Cockburn, la Arquitectura Hexagonal (tambi√©n llamada 
                        "Ports and Adapters") a√≠sla completamente la l√≥gica de negocio del mundo exterior.
                    </p>
                    <p>
                        Imagina el dominio como un hex√°gono en el centro, rodeado de puertos (interfaces) 
                        que se comunican con adaptadores (implementaciones concretas). Los puertos definen 
                        contratos, pero los adaptadores pueden cambiar.
                    </p>
                </div>

                <div class="pattern-card">
                    <h4>üèóÔ∏è Conceptos Clave:</h4>

                    <div class="concept-box">
                        <h5>Puertos</h5>
                        <p>
                            Son interfaces que define el dominio. No tienen implementaci√≥n, 
                            solo definen qu√© servicios espera el negocio.
                        </p>
                        <p><strong>Ejemplo:</strong> RepositorioPuerto, NotificadorPuerto, PagadorPuerto.</p>
                    </div>

                    <div class="concept-box">
                        <h5>Adaptadores</h5>
                        <p>
                            Implementan los puertos conectando el dominio con sistemas externos. 
                            Pueden haber m√∫ltiples adaptadores para el mismo puerto.
                        </p>
                        <p><strong>Ejemplo:</strong> 
                            - Para RepositorioPuerto: AdaptadorPostgres, AdaptadorMongo, AdaptadorMemoria
                            - Para NotificadorPuerto: AdaptadorEmail, AdaptadorSMS, AdaptadorPush
                        </p>
                    </div>

                    <div class="concept-box">
                        <h5>Puertos Primarios (Driving)</h5>
                        <p>
                            Son los que inician la comunicaci√≥n. Representan usuarios o sistemas 
                            que quieren interactuar con el negocio.
                        </p>
                        <p><strong>Ejemplo:</strong> API REST, CLI, UI web.</p>
                    </div>

                    <div class="concept-box">
                        <h5>Puertos Secundarios (Driven)</h5>
                        <p>
                            Son los que el negocio activa. Representan servicios que el negocio necesita.
                        </p>
                        <p><strong>Ejemplo:</strong> Base de datos, servicio de email, API externa.</p>
                    </div>
                </div>

                <div class="pattern-card">
                    <h4>‚úÖ Ventajas de Arquitectura Hexagonal:</h4>
                    <ul>
                        <li><strong>Aislamiento total del dominio:</strong> Negocio 100% independiente</li>
                        <li><strong>M√∫ltiples adaptadores:</strong> Mismo puerto, varias implementaciones</li>
                        <li><strong>Testeable:</strong> Adaptadores mock muy f√°ciles</li>
                        <li><strong>Flexible:</strong> Cambiar tecnolog√≠as sin tocar el dominio</li>
                        <li><strong>Claro:</strong> Diferencia entre adentro (negocio) y afuera (tech)</li>
                    </ul>
                </div>

                <div class="pattern-card">
                    <h4>‚ùå Desventajas de Arquitectura Hexagonal:</h4>
                    <ul>
                        <li><strong>M√°s verbosidad:</strong> Muchas interfaces y adaptadores</li>
                        <li><strong>Complejidad inicial:</strong> Met√°fora del hex√°gono confunde al principio</li>
                        <li><strong>Over-engineering:</strong> Puede no justificarse para proyectos peque√±os</li>
                    </ul>
                </div>

                <div class="pattern-card">
                    <h4>üí° Ejemplo Pr√°ctico:</h4>
                    <pre class="code-example">
// DOMINIO (Centro del hex√°gono)
class ServicioTransferencia {
    constructor(repositorioCuenta, notificador, procesadorPagos) {
        this.repositorioCuenta = repositorioCuenta; // Puerto
        this.notificador = notificador;              // Puerto
        this.procesadorPagos = procesadorPagos;      // Puerto
    }
    
    transferir(cuentaOrigen, cuentaDestino, monto) {
        const origen = this.repositorioCuenta.obtener(cuentaOrigen);
        const destino = this.repositorioCuenta.obtener(cuentaDestino);
        
        if (origen.saldo < monto) {
            throw new Error('Fondos insuficientes');
        }
        
        this.procesadorPagos.procesar(monto);
        
        origen.saldo -= monto;
        destino.saldo += monto;
        
        this.repositorioCuenta.guardar(origen);
        this.repositorioCuenta.guardar(destino);
        
        this.notificador.enviar(origen.email, 
            `Transferencia exitosa: ${monto}`);
        this.notificador.enviar(destino.email, 
            `Recibiste ${monto}`);
    }
}

// PUERTOS (Interfaces)
class RepositorioCuentaPuerto {
    obtener(id) { throw new Error('No implementado'); }
    guardar(cuenta) { throw new Error('No implementado'); }
}

class NotificadorPuerto {
    enviar(email, mensaje) { throw new Error('No implementado'); }
}

// ADAPTADORES (Implementaciones)
class RepositorioCuentaPostgres extends RepositorioCuentaPuerto {
    obtener(id) {
        // Consultar PostgreSQL
    }
    guardar(cuenta) {
        // Guardar en PostgreSQL
    }
}

class NotificadorEmail extends NotificadorPuerto {
    enviar(email, mensaje) {
        // Enviar por email
    }
}

class NotificadorSMS extends NotificadorPuerto {
    enviar(numero, mensaje) {
        // Enviar por SMS
    }
}

// PUERTA PRIMARIA (API REST - Adaptador de entrada)
class ControladorTransferencia {
    constructor(servicioTransferencia) {
        this.servicio = servicioTransferencia;
    }
    
    post(req, res) {
        try {
            this.servicio.transferir(
                req.body.cuentaOrigen,
                req.body.cuentaDestino,
                req.body.monto
            );
            res.json({ exitoso: true });
        } catch (error) {
            res.status(400).json({ error: error.message });
        }
    }
}
                    </pre>
                </div>

                <h3>3Ô∏è‚É£ Patr√≥n CQRS (Command Query Responsibility Segregation)</h3>

                <div class="pattern-card">
                    <h4>üìö Descripci√≥n General:</h4>
                    <p>
                        CQRS es un patr√≥n que separa las operaciones de lectura (Queries) 
                        de las operaciones de escritura (Commands). Mientras que tradicionalmente 
                        usamos el mismo modelo de datos para leer y escribir, CQRS permite tener 
                        modelos completamente diferentes optimizados para cada prop√≥sito.
                    </p>
                </div>

                <div class="pattern-card">
                    <h4>üèóÔ∏è Conceptos Clave:</h4>

                    <div class="concept-box">
                        <h5>Commands (Comandos)</h5>
                        <p>
                            Representan una intenci√≥n de cambiar el estado del sistema. 
                            Son s√≠ncronos o as√≠ncronos y pueden fallar.
                        </p>
                        <p><strong>Ejemplo:</strong> CrearUsuarioCommand, ActualizarPerfilCommand, TransferirDineroCommand.</p>
                    </div>

                    <div class="concept-box">
                        <h5>Queries (Consultas)</h5>
                        <p>
                            Representan una solicitud de lectura. No modifican estado, 
                            solo retornan datos optimizados para la lectura.
                        </p>
                        <p><strong>Ejemplo:</strong> ObtenerUsuarioPorIdQuery, ListarTodosLosUsuariosQuery, 
                        ObtenerReportesVentasQuery.</p>
                    </div>

                    <div class="concept-box">
                        <h5>Command Bus / Query Bus</h5>
                        <p>
                            Mecanismos que enrutan Commands y Queries a sus handlers correspondientes. 
                            Permiten desacoplamiento entre quien emite la operaci√≥n y quien la maneja.
                        </p>
                    </div>

                    <div class="concept-box">
                        <h5>Event Sourcing (Opcional pero com√∫n con CQRS)</h5>
                        <p>
                            En lugar de guardar el estado actual, se guardan todos los eventos que 
                            ocurrieron. Desde estos eventos se puede reconstruir el estado en cualquier momento.
                        </p>
                        <p><strong>Ejemplo:</strong> En lugar de guardar "usuario.activo = true", 
                        guardamos el evento "UsuarioActivadoEvent".</p>
                    </div>
                </div>

                <div class="pattern-card">
                    <h4>‚úÖ Ventajas de CQRS:</h4>
                    <ul>
                        <li><strong>Rendimiento optimizado:</strong> Lecturas y escrituras independientes</li>
                        <li><strong>Escalabilidad:</strong> Escalar lecturas y escrituras por separado</li>
                        <li><strong>Seguridad:</strong> Diferentes reglas para lectura y escritura</li>
                        <li><strong>Flexibilidad:</strong> Diferentes modelos de datos para cada caso</li>
                        <li><strong>Auditor√≠a:</strong> Historial completo de cambios (con Event Sourcing)</li>
                        <li><strong>Sincronizaci√≥n compleja:</strong> F√°cil implementar cache, replicas, ETL</li>
                    </ul>
                </div>

                <div class="pattern-card">
                    <h4>‚ùå Desventajas de CQRS:</h4>
                    <ul>
                        <li><strong>Complejidad a√±adida:</strong> Dos modelos de datos diferentes</li>
                        <li><strong>Consistencia eventual:</strong> Los datos pueden estar desactualizados</li>
                        <li><strong>Testing m√°s complicado:</strong> M√°s casos a considerar</li>
                        <li><strong>Debugging dif√≠cil:</strong> L√≥gica distribuida es m√°s compleja</li>
                        <li><strong>Over-engineering:</strong> No siempre necesario</li>
                    </ul>
                </div>

                <div class="pattern-card">
                    <h4>üí° Ejemplo Pr√°ctico:</h4>
                    <pre class="code-example">
// COMMANDS
class CrearProductoCommand {
    constructor(nombre, precio) {
        this.nombre = nombre;
        this.precio = precio;
    }
}

class ActualizarInventarioCommand {
    constructor(productoId, cantidad) {
        this.productoId = productoId;
        this.cantidad = cantidad;
    }
}

// COMMAND HANDLERS
class CrearProductoHandler {
    constructor(repositorio) {
        this.repositorio = repositorio;
    }
    
    manejar(command) {
        const producto = {
            id: UUID.generar(),
            nombre: command.nombre,
            precio: command.precio,
            creado: new Date()
        };
        
        this.repositorio.guardarProducto(producto);
        // Emitir evento: ProductoCreadoEvent
        
        return producto;
    }
}

// QUERIES
class ObtenerProductosPorCategoriaQuery {
    constructor(categoria) {
        this.categoria = categoria;
    }
}

class ObtenerEstadisticasVentasQuery {
    constructor(fechaInicio, fechaFin) {
        this.fechaInicio = fechaInicio;
        this.fechaFin = fechaFin;
    }
}

// QUERY HANDLERS
class ObtenerProductosPorCategoriaHandler {
    constructor(cacheProductos) {
        this.cacheProductos = cacheProductos; // Cache optimizado para lectura
    }
    
    manejar(query) {
        // Retorna productos desde cache (ultra r√°pido)
        return this.cacheProductos.obtenerPorCategoria(query.categoria);
    }
}

class ObtenerEstadisticasVentasHandler {
    constructor(baseDatosAnalitica) {
        this.baseDatosAnalitica = baseDatosAnalitica; // BD especial para reportes
    }
    
    manejar(query) {
        // Consulta desde BD anal√≠tica (pre-agregada)
        return this.baseDatosAnalitica.obtenerVentasEnRango(
            query.fechaInicio,
            query.fechaFin
        );
    }
}

// COMMAND BUS
class CommandBus {
    constructor(handlers) {
        this.handlers = handlers;
    }
    
    ejecutar(command) {
        const handler = this.handlers[command.constructor.name];
        return handler.manejar(command);
    }
}

// QUERY BUS
class QueryBus {
    constructor(handlers) {
        this.handlers = handlers;
    }
    
    ejecutar(query) {
        const handler = this.handlers[query.constructor.name];
        return handler.manejar(query);
    }
}

// USO
const commandBus = new CommandBus({
    'CrearProductoCommand': new CrearProductoHandler(repo)
});

const queryBus = new QueryBus({
    'ObtenerProductosPorCategoriaQuery': 
        new ObtenerProductosPorCategoriaHandler(cache)
});

// Crear producto (escritura optimizada)
commandBus.ejecutar(new CrearProductoCommand('Laptop', 999));

// Consultar productos (lectura optimizada)
const productos = queryBus.ejecutar(
    new ObtenerProductosPorCategoriaQuery('Electr√≥nica')
);
                    </pre>
                </div>

                <h3>üìä Tabla Comparativa de Patrones Modernos</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Aspecto</th>
                            <th>Clean Architecture</th>
                            <th>Hexagonal</th>
                            <th>CQRS</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Enfoque Principal</strong></td>
                            <td>Capas conc√©ntricas</td>
                            <td>Puertos y adaptadores</td>
                            <td>Lectura vs Escritura</td>
                        </tr>
                        <tr>
                            <td><strong>Independencia</strong></td>
                            <td>De frameworks</td>
                            <td>Total del sistema externo</td>
                            <td>De modelos de datos</td>
                        </tr>
                        <tr>
                            <td><strong>Testabilidad</strong></td>
                            <td>Muy alta</td>
                            <td>Muy alta</td>
                            <td>Alta (m√°s casos)</td>
                        </tr>
                        <tr>
                            <td><strong>Complejidad</strong></td>
                            <td>Media</td>
                            <td>Media-Alta</td>
                            <td>Alta</td>
                        </tr>
                        <tr>
                            <td><strong>Escalabilidad</strong></td>
                            <td>Media</td>
                            <td>Media</td>
                            <td>Alta</td>
                        </tr>
                        <tr>
                            <td><strong>Curva de Aprendizaje</strong></td>
                            <td>Media</td>
                            <td>Media</td>
                            <td>Alta</td>
                        </tr>
                        <tr>
                            <td><strong>Mejor para</strong></td>
                            <td>Apps empresariales medianas</td>
                            <td>Sistemas altamente desacoplados</td>
                            <td>Sistemas de alto rendimiento</td>
                        </tr>
                    </tbody>
                </table>

                <h3>üí° Ejemplos de Aplicaci√≥n en Proyectos Modernos</h3>

                <div class="application-box">
                    <h4>Clean Architecture</h4>
                    <p><strong>Proyectos donde se usa:</strong></p>
                    <ul>
                        <li>Aplicaciones de enterprise que necesitan durar a√±os</li>
                        <li>Proyectos donde el negocio es complejo y requiere cambios frecuentes</li>
                        <li>Equipos grandes con diferentes especializaciones</li>
                    </ul>
                    <p><strong>Ejemplo real:</strong> Un sistema de banca digital donde la l√≥gica de 
                    validaciones, c√°lculo de intereses, y reglas de fraude NO pueden depender 
                    de si usamos Spring o Quarkus, PostgreSQL o MongoDB.</p>
                </div>

                <div class="application-box">
                    <h4>Arquitectura Hexagonal</h4>
                    <p><strong>Proyectos donde se usa:</strong></p>
                    <ul>
                        <li>Sistemas que necesitan m√∫ltiples interfaces (web, mobile, CLI, eventos)</li>
                        <li>Proyectos integrando sistemas legacy con nuevos</li>
                        <li>Microservicios con l√≥gica de negocio compleja</li>
                    </ul>
                    <p><strong>Ejemplo real:</strong> Un servicio de notificaciones que puede enviar 
                    por Email, SMS, Push, WhatsApp sin modificar la l√≥gica central. 
                    Cada adaptador es independiente.</p>
                </div>

                <div class="application-box">
                    <h4>CQRS</h4>
                    <p><strong>Proyectos donde se usa:</strong></p>
                    <ul>
                        <li>Sistemas con alto volumen de lecturas (reportes, dashboards)</li>
                        <li>Aplicaciones con requisitos de auditor√≠a estrictos</li>
                        <li>Sistemas distribuidos con consistencia eventual</li>
                    </ul>
                    <p><strong>Ejemplo real:</strong> Una plataforma de analytics donde miles de usuarios 
                    consultan reportes simult√°neamente, mientras otros escriben nuevos datos. 
                    Las escrituras van a una BD optimizada, las lecturas desde un cache de reportes pre-calculados.</p>
                </div>

                <h3>üéì Conclusi√≥n General: Comparando los Tres Patrones</h3>

                <div class="conclusion-box">
                    <h4>üîç Resumen Comparativo</h4>
                    <p>
                        <strong>Clean Architecture</strong> es la m√°s general y aplicable. 
                        Proporciona una estructura s√≥lida que funciona bien en la mayor√≠a de proyectos. 
                        Es el "est√°ndar de oro" para arquitectura desacoplada.
                    </p>
                    <p>
                        <strong>Arquitectura Hexagonal</strong> es m√°s espec√≠fica en su enfoque. 
                        Excele cuando necesitas m√∫ltiples adaptadores o integraciones complejas. 
                        Es especialmente poderosa para testing y flexibilidad t√©cnica.
                    </p>
                    <p>
                        <strong>CQRS</strong> es m√°s especializado y NO reemplaza a los otros dos. 
                        De hecho, frecuentemente se COMBINA con Clean Architecture o Hexagonal. 
                        Es para problemas espec√≠ficos: alto rendimiento en lecturas, auditor√≠a, 
                        o sistemas distribuidos complejos.
                    </p>

                    <h4>üìå Combinaciones Comunes</h4>
                    <ul>
                        <li><strong>Clean + CQRS:</strong> Arquitectura de capas con separaci√≥n de lectura/escritura</li>
                        <li><strong>Hexagonal + CQRS:</strong> M√∫ltiples adaptadores + separaci√≥n de modelos</li>
                        <li><strong>Los tres juntos:</strong> Proyectos de ultra-complejidad (Amazon, Netflix)</li>
                        <li><strong>Solo Clean:</strong> Mayor√≠a de proyectos empresariales</li>
                        <li><strong>Solo Hexagonal:</strong> Integraciones complejas</li>
                        <li><strong>Solo CQRS:</strong> Raro, casi siempre combinado con otro</li>
                    </ul>

                    <h4>üéØ Recomendaci√≥n Final</h4>
                    <p>
                        Para la mayor√≠a de proyectos nuevos, comienza con <strong>Clean Architecture</strong>. 
                        Es lo suficientemente flexible para evolucionar. Si necesitas flexibilidad extrema 
                        en adaptadores, agrega <strong>Hexagonal</strong>. Si el rendimiento de lecturas 
                        es cr√≠tico, introduc <strong>CQRS</strong>.
                    </p>
                    <p>
                        Recuerda: <strong>No es "todo o nada"</strong>. Puedes aplicar estos patrones 
                        parcialmente, modulando su complejidad seg√∫n tus necesidades reales.
                    </p>
                </div>
            </section>
        </article>
    </main>

    <!-- PIE DE P√ÅGINA -->
    <footer class="main-footer">
        <div class="footer-content">
            <p>&copy; 2025 Blog T√©cnico - Arquitectura de Software</p>
            <p>Autor: <strong>Daniel Felipe Cifuentes Quiroga</strong> | COG: <strong>84608</strong></p>
            <p>Materia: Electiva de Ingenier√≠a de Software</p>
            <p class="social-links">
                <a href="https://github.com" target="_blank">GitHub</a> | 
                <a href="https://linkedin.com" target="_blank">LinkedIn</a>
            </p>
        </div>
    </footer>

    <script src="js/main.js"></script>
</body>
</html>
